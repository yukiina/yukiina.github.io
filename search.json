[{"title":"Hello World","date":"2021-05-30T14:21:40.387Z","url":"/Demo/hello-world/","tags":[["Tag0","/tags/Tag0/"],["Tag1","/tags/Tag1/"],["Tag2","/tags/Tag2/"]],"categories":[["Demo","/categories/Demo/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 折叠框的标题 被折叠的内容 1被折叠的内容 2… 折叠框的标题 被折叠的内容 1被折叠的内容 2… 面板框的标题 面板里的内容 1面板里的内容 2… "},{"title":"2. 从零开始的Python源码学习-对象的行为","date":"2021-05-29T09:36:00.000Z","url":"/Python/Python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA/2.%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E4%B8%BA/","tags":[["Python","/tags/Python/"],["Python源码","/tags/Python%E6%BA%90%E7%A0%81/"]],"categories":[["Python","/categories/Python/"]],"content":"​ 在Python中创建的每一个对象, 会分配一个对应的结构体, 并统一转换为PyObject*来管理, 其中ob_type保存了对象的类型, 不同的类型决定了不同对象的行为。 一. 对象的创建​ 在Python中创建一个内置对象通常有两种方式, 一种直接使用赋值语句, 解释器会自动推导对象的类型, 一种是和自定义类型一样使用类型()的方式创建。 ​ 内置类型使用两种方式都可以创建对象, 那么这两种方式创建对象有没有什么区别呢, 我们都知道推荐的方式是内置类型使用第一种方式创建, 因为两种方式创建时执行效率是有差别的: ​ 因为内置类型都是由Python提供的, 解释器可以推断类型, 选择特型C API调用直接创建; 内置对象创建 使用 var = 1.1 形式创建对象, 直接调用PyFloat_FromDouble() 创建, 然后返回PyObject* 。 call方式创建 使用var = float(1.1)形式创建, 在float_new处设置断点, 可以观察到调用堆栈是由type_call处调用到float_new的。 ​ 以 var1 = float(1.1), float 类型为例, 学习一下tp_call()是怎么创建对象的。 Tips: var1 = float(1.1) float 的类型是type, 所以要找的其实是PyType_Type的tp_call() 可以理解为一个对象(float)的行为全部依赖于类型(type)的定义 type_call ​ 可以看到type_call根据传入参数type的不同, 调用type中的tp_new和tp_init方法, 所以我们在Python中才可以使用xxx()的形式创建内置类型或自定义类型, 这里也能看出, 对象的行为由对象的类型决定, 准确的说是由类型中的函数确定, tp_call 不需要关心具体是什么类型, 只要调用这两个函数就行。 tp_new: 为类型实例申请内存, 通过obj.__new__(cls)方式申请, 然后返回。 tp_init: tp_new的返回值传递给tp_init, 绑定self, 然后进行参数初始化。 ​ tp_new 和 tp_init 其实在自定义类型中就是 __new__() 和 __init() 这两个函数, 所以我们在定义自定义类型时通过这两个定义了实例化对象的行为, 创建对象时由 tp_call 来调用。 二. tp_new 和tp_init​ 在第一节中我们了解到自定义类型是如何被Python创建的, __init__()和__new__()通过定义这两个魔法函数来控制自己的自定义类型创建的行为。不过__new()__这个平时比较少用到, 也有一些隐藏的”特殊规则”。 ​ __new__(cls, *args, **kwargs)这个入参以及返回值return object.__new__(cls)基本都是固定写法。可以再对照源码观察一下 tp_new 和 tp_init 。 ​ 所以平时我们创建自定义对象时分了分配空间和初始化对象两个步骤, 分别是 tp_new 和 tp_init , 不过平时需要用到 tp_new 的情况比较少。 三. 引用计数​ 垃圾回收是现代编程语言的重要机制, 将维护内存分配的工作交给运行环境, 牺牲了运行效率但是提高了开发的效率, Python中也有垃圾回收机制, 其中引用计数是垃圾回收机制中重要的一部分。 ​ PyObject中的ob_recnt成员维护了该对象的引用计数, 决定了对象创建和消亡。 对象创建出来的时候引用计数为1 对象被引用, 引用计数 +1 对象解除引用, 引用计数 -1 对象引用计数为0, 对象析构 上述的关于引用计数的认知是十分符合我们的认知, 常见的引用计数基本都是按照这一套规则设计的。 ​ 析构的时候找到了对应类型的tp_dealloc, 所以类型不仅决定了对象的创建行为, 对象销毁的行为也由类型中的tp_dealloc决定, 不仅如此, Python中对象能实现的各种操作都由对象的类型决定。 四. 对象的行为​ 不同的类型支持不同的操作, 相同的操作因为对象的不同实现也不相同, 比如tp_hash(), 能够哈希的类型就可以实现 tp_hash 这个函数, 不能哈希的类型, 这一操作就为 0 。 ​ 当Python尝试使用hash()获取对象的哈希值时, 调用 PyObject_Hash() 获取对象类型的 tp_hash 操作。 ​ 不同的对象底层的类型不同, 支持不同的操作, 但是类型之间又会有一些共性, Python根据操作的差异抽象了三种操作函数集结构体, 将这一种操作的方法整合为一个结构体: 数值类型: 整数, 浮点数 序列类型: 列表, 元组 映射类型: 字典 ​ 我们以浮点数float为例学习一下这三个函数操作集在类型对象上的应用: ​ 从上面的代码中可以观察到, float类型只支持数值类型的操作, 操作的函数在float_as_number中。 END: 参考链接 《深度剖析CPython解释器》系列博客:  "},{"title":"1. 从零开始的Python源码学习-类与对象","date":"2021-05-28T05:52:00.000Z","url":"/Python/Python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/1.%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","tags":[["Python","/tags/Python/"],["Python源码","/tags/Python%E6%BA%90%E7%A0%81/"]],"categories":[["Python","/categories/Python/"]],"content":"在Python中一切皆对象, Python的动态性依赖于底层的对象系统的设计, 学习和理解Python对象系统, 是学习Python源码的第一步。 一. Python一切皆对象​ 在传统面向对象的语言中, 一般有”类”和”对象”的概念, 通过定义的”类”来实例化”对象”; 然而在Python中一切皆对象, 不管是”类”还是”对象”都是对象。”类”被称为类型对象, 实例化的”对象”被称为实例对象。 ​ 从上面的示例中了解到, int, str等类型对象是由type实例化得到的类型对象, 因为Python中一切皆对象的设计, type的类型也被设计为了type, type也被称为元类。 Python中一切皆对象: 实例对象, 类型对象, 元类 ​ 在传统面向对象中类型的继承, Python中也有一个很特殊的类型对象, 所有类继承的终点object。 ​ 从上面的示例中我们学习了另一个特殊的类型对象object, 是所有类型的最终的基类, 也包括元类, 所以就有一组特殊的关系, 这两个对象的关系需要后面的知识才能进一步解释: type继承自object object类型是type 最后Python中一切皆对象的类型对象系统可以总结为如下的一张图 二. PyObject — 对象机制核心​ Python中的任何对象都对应C的一个结构体实例, Python中创建一个对象的本质上相当于C中malloc函数为对应的结构体在堆区申请一块内存。Python将所有对象共有部分抽象成了一个结构体PyObject, 是整个对象系统的基石。 PyObject结构体的定义在Python2/3中基本相同, 文章还是以Python2为主。 ​ PyObject_HEAD从名字上看大概能猜到这是一个公共的头部信息, Python中每一个对象的拥有这个头部信息, PyObject_HEAD是一个宏, 展开后定义了一个_PyObject_HEAD_EXTRA的宏, 将其全部展开: PyObject _ob_next &amp; _ob_prev: 维护了一个名叫refchain的双向链表, Python会将程序中创建的所有对象放入这个链表中, 用于跟踪所有的活跃的堆对象, 这个宏仅在Debug下有用。不是当前关注的重点。 ob_refcnt: ob_refcnt表示当前对象的引用计数, 当对象被引用时, ob_refcnt自增1, 引用解除时, ob_refcnt自减1。引用计数为0时, 对象会被回收。 使用 del 删除一个对象时, 使对象的引用计数 -1, 引用计数为 0 时, 解释器会删除对象。 ob_refcnt的类型为Py_ssize_t, 64位机器上等同于 long。 ob_type: ob_type表示当前对象的类型信息的指针。类型信息是一个 struct _typeobject 结构体。 ​ Python中的任意对象都拥有: 引用计数和类型信息这两个属性。 ​ 因此在Python中, 对象的引用就变得非常统一, PyObject* 就可以引用任何一个类型, 不需要知道这个对象的实际类型, 这也是Python动态语言的基础。在Python 中所有的对象, 以及容器内的元素本质上都是PyObject* 。 ​ int是PyObject*, int实例化生成的对象是PyObject* , type是PyObject*, object也是PyObject* 。这也就解释了Python中为什么一切皆对象。 三. PyVarObject — 可变长对象​ PyObject结构体有一个很常用的扩展类型, PyVarObject可变长对象, 结构体内部多存储一个元素的数量, Python中列表等可变长对象都直接使用了这个结构体。 ​ 因为PyObject和PyVarObject使用广泛, Python定义了两个宏PyObject_HEAD和PyObject_VAR_HEAD, 表示这两种对象的成员, 常见于各种对象的结构体定义中。 四. PyTypeObject — 类型系统核心​ 在PyObject的结构体中有一个类型信息的成员, struct _typeobject*, 又被命名为PyTypeObject。 ​ PyTypeObject定义了对象的元信息, 名字, 支持的操作等, Python所有的类型对象都是由PyTypeObject定义的对象, 在C层面对应了一个全局变量。例如Python中的float类型对应了PyFloat_Type: PyFloat_Type PyVarObject_HEAD_INIT 是一个宏, 用于初始化, PyObject_VAR_HEAD, 借助IDE看一下宏展开: PyFloat_Type的 ob_type被设置为了PyType_Type, PyType_Type对应Python的type, 这也能解释Python中float的类型是type。 tp_name 名字被设置为float, 对应Python中的名字。 sizeof(PyFloatObject) 保存定义一个float对象的内存大小。 ​ 其实类型对象的命名非常有规律, 基本都是PyXXX_Type, 如: PyFloat_Type, PyType_Type。 ​ 同理实例对象的命名, 基本都是PyXXXObject, 如: PyFloatObject, PyLongObject。 ​ 但是所有的类型对象都是PyTypeObject类型, 实例对象则使用对应的类型创建, 如下表: 类型 实例对象 类型对象 整型 PyLongObject类型 PyLong_Type(PyTypeObject类型) 字符串 PyUnicodeObject类型 PyUnicode_Type(PyTypeObject类型) 浮点数 PyFloatObject类型 PyFloat_Type(PyTypeObject类型) 复数 PyComplexObject类型 PyComplex_Type(PyTypeObject类型) 元组 PyTupleObject类型 PyTuple_Type(PyTypeObject类型) 列表 PyListObject类型 PyList_Type(PyTypeObject类型) 字典 PyDictObject类型 PyDict_Type(PyTypeObject类型) 集合 PySetObject类型 PySet_Type(PyTypeObject类型) 元类 PyType_Type(PyTypeObject类型) ​ PyXXXObject和PyXXX_Type的对应关系如下图所示: Python动态性和弊端 ​ Python底层通过PyObject和PyTypeObject完成了C++所提供的对象的多态特性。 ​ 在Python中创建一个对象，会分配内存并进行初始化，然后Python会用一个PyObject *来保存和维护这个对象, 所以变量在保存一个对象的指针时，会将该指针转成PyObject *之后再交给变量保存。 ​ 因此在Python中，变量的传递实际上传递的都是一个泛型指针：PyObject *。这个指针具体是指向的什么类型我们并不知道，只能通过其内部的ob_type成员进行动态判断，而正是因为这个ob_type，Python实现了动态性。 ​ 所以Python速度慢的很大一部分原因是有相当一部分时间浪费在类型和属性的查找上面的。 五. PyType_Type与PyBaseObject_TypeTips: object类型对应的是PyBaseObject_Type, 而不是PyObject_Type!!! ​ 回顾之前的内容, type是所有类型的类型, object所有类型的基类, 通过学习这两个类型对象的底层数据结构PyType_Type和PyBaseObject_Type来理解它们之间的关系。 PyType_Type 初始化设置ob_type为PyType_Type, 这也就解释了为什么type的类型是type。 Python中的名字设置为type。 这里tp_base基类设置为0, 这里理论上应该是object才对, 不过因为这是一个全局变量, 运行前是不知道PyBaseObject_Type的地址的, 当然就只能先设置为0。运行之后看一下这个变量, 发现tp_base确实被设置了PyBaseObject_Type, 这与我们在Python层面上的理解一致。 ​ 然后再来看一下object类型对象底层PyBaseObject_Type的结构: PyBaseObject_Type 初始化设置ob_type为PyType_Type, 所以object的类型也是type。 Python中的名字是object。 object是最终的基类, 所以tp_base为0, 运行看一下是否还是0。 ​ 现在应该可以完全理解为什么type继承于object, 而object的类型是type, 这个在Python层面上看似像一个闭环的问题。 ​ Python通过设计抽象的PyObject使得对象和类型的边界模糊, 在底层任何对象都可以强制转换为PyObject* 。 END: 参考链接 《深度剖析CPython解释器》系列博客:   "},{"title":"0. 从零开始的Python源码学习-准备工作","date":"2021-05-27T03:10:00.000Z","url":"/Python/Python%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0.%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/0.%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","tags":[["Python","/tags/Python/"],["Python源码","/tags/Python%E6%BA%90%E7%A0%81/"]],"categories":[["Python","/categories/Python/"]],"content":"之前对于Python的学习一直停留在Python层, 最近准备开始学习一下Python的源码, 顺便记录下自己的学习笔记。 一. 环境准备 下载链接 Python源码:  宇宙第一IDE:  Python的源码我下载了Python-2.7.18 和 Python-3.7.7, 因为工作中使用Python2。Python3和Python2的源码会有一些区别(Python3不同小版本都会有一些优化), 文章主要以这两个版本作为示例。 Visual Stuido 使用的是2019版本, 2017也可以, Visual Studio版本最好 &gt;=2017。 二. 编译Python3源码 找到源码目录下的路径Python-3.7.7\\PCBuild\\pcbuild.sln, 双击打开。 根据版本的不同VS可能会检查并升级SDK, 这里选择WindowsSDK:无升级, 平台工具集: 升级。 解决方案 右键-属性-选择配置属性, 生成一列只留下python和pythoncore, 其他取消勾选。 解决方案 右键-生成解决方案 完成后 F5或点击调试 就可以看到运行了Python的交互界面。 Python3的源码就编译完成啦~ 三. 编译Python2源码Python2源码的编译和Python3差不多, 不过有些代码需要修改。 找到源码目录下的路径Python-2.7.18\\PCBuild\\pcbuild.sln, 双击打开。 python2基本上一定会提示升级, 同上选择WindowsSDK:无升级, 平台工具集: 升级。 解决方案 右键-属性-选择配置属性, 生成一列只留下python和pythoncore, 其他取消勾选。 解决方案 右键-生成解决方案 , 编译过程中会提示编译错误, 修改代码解决这些编译错误。 首先是timemodule.c中的宏定义不再被高版本vs支持, 报错的宏加上下划线。 再次编译, 发现还是有报错, 搜索pythoncore工程下的posixmodule.c中的_PyVerify_fd, 全部注释修改如下。 修改后再次编译, 编译成功~ Tips: 如果修改opcode编译运行会报错, 需要删除Lib目录的所有pyc以及Libencoding目录下所有pyc后再次编译运行。 四. 源码目录结构 下载解压后, 目录结构如上图所示, 其中有一些需要我们关注: 目录结构 Include: 包含Python提供的所有头文件。 Lib: 包含了Python自带的标准库, 基本用Python编写。 Module: 包含了所有用C语言写的模块。 Parser: 包含Python解释器中的词法分析和语法分析源码以及一些工具。 Object: Python内置类型对象的实现文件。 Python: CPython解释器源码。 PCBuild: Windows生成文件, for MSVC。 END: 参考链接 如何编译和调试Python内核源码？:  PYTHON C++混合编程笔记（一）- VS2017 编译 python 2.7:  《深度剖析CPython解释器》4. 解密Python中最简单的对象–浮点数的底层实现:  "},{"title":"hello","date":"2021-05-26T12:01:41.000Z","url":"/Demo/%E6%9D%82%E9%A1%B9/0.%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","tags":[["Tag0","/tags/Tag0/"],["Tag1","/tags/Tag1/"],["Tag2","/tags/Tag2/"]],"categories":[["Demo","/categories/Demo/"]],"content":"文章概要 "},{"title":"hello","date":"2021-05-26T12:01:41.000Z","url":"/Demo/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/UGUI/0.%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","tags":[["Tag0","/tags/Tag0/"],["Tag1","/tags/Tag1/"],["Tag2","/tags/Tag2/"]],"categories":[["Demo","/categories/Demo/"]],"content":"文章概要 "}]